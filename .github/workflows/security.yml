name: üõ°Ô∏è Security Scanning & Compliance

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run security scans daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of security scan to run'
        required: false
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'code_analysis'
          - 'dependency_check'
          - 'secrets_scan'
          - 'container_scan'
      severity_threshold:
        description: 'Minimum severity to report'
        required: false
        default: 'medium'
        type: choice
        options:
          - 'low'
          - 'medium'
          - 'high'
          - 'critical'

env:
  SCAN_TYPE: ${{ github.event.inputs.scan_type || 'all' }}
  SEVERITY_THRESHOLD: ${{ github.event.inputs.severity_threshold || 'medium' }}

jobs:
  codeql-analysis:
    name: üîç CodeQL Analysis
    runs-on: ubuntu-latest
    if: contains(fromJson('["all", "code_analysis"]'), env.SCAN_TYPE)
    
    permissions:
      actions: read
      contents: read
      security-events: write
    
    strategy:
      fail-fast: false
      matrix:
        language: [ 'python', 'javascript' ]
    
    steps:
      - name: üìÇ Checkout repository
        uses: actions/checkout@v4
        
      - name: üîç Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: ${{ matrix.language }}
          queries: security-extended,security-and-quality
          
      - name: üèóÔ∏è Autobuild
        uses: github/codeql-action/autobuild@v2
        
      - name: üîç Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
        with:
          category: "/language:${{matrix.language}}"

  dependency-security:
    name: üì¶ Dependency Security Scan
    runs-on: ubuntu-latest
    if: contains(fromJson('["all", "dependency_check"]'), env.SCAN_TYPE)
    
    steps:
      - name: üìÇ Checkout repository
        uses: actions/checkout@v4
        
      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          
      - name: üì¶ Install security tools
        run: |
          pip install safety pip-audit bandit[toml]
          
      - name: üîç Safety dependency scan
        run: |
          echo "üîç Running Safety dependency scan..."
          
          if [ -f requirements.txt ]; then
            echo "üìã Scanning requirements.txt..."
            safety check -r requirements.txt --json --output safety-report.json || true
            safety check -r requirements.txt || echo "‚ö†Ô∏è Vulnerabilities found in requirements.txt"
          fi
          
          if [ -f requirements-dev.txt ]; then
            echo "üìã Scanning requirements-dev.txt..."
            safety check -r requirements-dev.txt || echo "‚ö†Ô∏è Vulnerabilities found in requirements-dev.txt"
          fi
          
          # Check currently installed packages
          echo "üìã Scanning installed packages..."
          safety check --json --output safety-installed.json || true
          safety check || echo "‚ö†Ô∏è Vulnerabilities found in installed packages"
          
      - name: üïµÔ∏è Pip-audit scan
        run: |
          echo "üïµÔ∏è Running pip-audit scan..."
          
          if [ -f requirements.txt ]; then
            pip-audit -r requirements.txt --format=json --output=pip-audit-report.json || true
            pip-audit -r requirements.txt || echo "‚ö†Ô∏è pip-audit found vulnerabilities"
          fi
          
      - name: üõ°Ô∏è Advanced dependency analysis
        run: |
          echo "üõ°Ô∏è Running advanced dependency analysis..."
          
          # Check for outdated packages
          if [ -f requirements.txt ]; then
            echo "üìä Checking for outdated packages..."
            pip list --outdated --format=json > outdated-packages.json
            
            OUTDATED_COUNT=$(jq length outdated-packages.json)
            echo "üìä Found $OUTDATED_COUNT outdated packages"
            
            if [ $OUTDATED_COUNT -gt 0 ]; then
              echo "üìã Outdated packages:"
              jq -r '.[] | "\(.name): \(.version) -> \(.latest_version)"' outdated-packages.json
            fi
          fi
          
          # License check
          echo "üìÑ Checking package licenses..."
          pip install pip-licenses
          pip-licenses --format=json --output-file=licenses.json
          
          # Check for restrictive licenses
          RESTRICTIVE_LICENSES='["GPL", "AGPL", "LGPL"]'
          echo "$RESTRICTIVE_LICENSES" | jq -r '.[]' | while read license; do
            if jq -e --arg lic "$license" '.[] | select(.License | contains($lic))' licenses.json >/dev/null; then
              echo "‚ö†Ô∏è Found packages with restrictive license: $license"
              jq -r --arg lic "$license" '.[] | select(.License | contains($lic)) | "\(.Name): \(.License)"' licenses.json
            fi
          done
          
      - name: üìã Upload dependency reports
        uses: actions/upload-artifact@v3
        with:
          name: dependency-security-reports
          path: |
            safety-report.json
            safety-installed.json
            pip-audit-report.json
            outdated-packages.json
            licenses.json

  secrets-scan:
    name: üîê Secrets Scanning
    runs-on: ubuntu-latest
    if: contains(fromJson('["all", "secrets_scan"]'), env.SCAN_TYPE)
    
    steps:
      - name: üìÇ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for better secret detection
          
      - name: üîê Install secret scanning tools
        run: |
          # Install gitleaks
          wget -O gitleaks.tar.gz https://github.com/zricethezav/gitleaks/releases/latest/download/gitleaks_*_linux_x64.tar.gz
          tar -xzf gitleaks.tar.gz
          chmod +x gitleaks
          sudo mv gitleaks /usr/local/bin/
          
      - name: üîç Gitleaks secret scan
        run: |
          echo "üîç Running Gitleaks secret scan..."
          
          # Scan for secrets in entire repository history
          gitleaks detect --source . --report-format json --report-path gitleaks-report.json --verbose || true
          
          # Display results
          if [ -s gitleaks-report.json ]; then
            echo "üö® Secrets found:"
            cat gitleaks-report.json | jq '.[] | {file: .File, secret: .Secret[0:20], rule: .RuleID}'
            
            SECRET_COUNT=$(jq length gitleaks-report.json)
            echo "üö® Total secrets found: $SECRET_COUNT"
            
            if [ $SECRET_COUNT -gt 0 ]; then
              echo "‚ùå Security scan failed due to secrets"
              exit 1
            fi
          else
            echo "‚úÖ No secrets found"
          fi
          
      - name: üîç Custom secret patterns
        run: |
          echo "üîç Scanning for custom secret patterns..."
          
          # Custom patterns for common secrets
          SECRET_PATTERNS=(
            "LINEAR_API_KEY.*lin_api_[a-zA-Z0-9]+"
            "GITHUB_TOKEN.*gh[ps]_[a-zA-Z0-9]{36}"
            "AWS_ACCESS_KEY_ID.*AKIA[0-9A-Z]{16}"
            "SLACK_TOKEN.*xox[baprs]-[0-9a-zA-Z]+"
            "DISCORD_TOKEN.*[MN][A-Za-z\d]{23}\.[A-Za-z\d]{6}\.[A-Za-z\d]{27}"
          )
          
          SECRETS_FOUND=false
          
          for pattern in "${SECRET_PATTERNS[@]}"; do
            echo "Checking pattern: $pattern"
            if grep -r -E "$pattern" . --exclude-dir=.git --exclude-dir=node_modules --exclude-dir=venv 2>/dev/null; then
              echo "üö® Found potential secret matching pattern: $pattern"
              SECRETS_FOUND=true
            fi
          done
          
          if [ "$SECRETS_FOUND" = true ]; then
            echo "‚ùå Custom secret scan failed"
            exit 1
          else
            echo "‚úÖ No custom secrets found"
          fi
          
      - name: üîç Environment variable validation
        run: |
          echo "üîç Validating environment variable usage..."
          
          # Check for hardcoded values that should be environment variables
          HARDCODED_PATTERNS=(
            "lin_api_[a-zA-Z0-9]+"
            "gh[ps]_[a-zA-Z0-9]{36}"
            "https://hooks.slack.com/services/"
            "https://discord.com/api/webhooks/"
          )
          
          HARDCODED_FOUND=false
          
          for pattern in "${HARDCODED_PATTERNS[@]}"; do
            if grep -r -E "$pattern" . --exclude-dir=.git --exclude-dir=node_modules --exclude-dir=venv 2>/dev/null; then
              echo "‚ö†Ô∏è Found hardcoded value that should be an environment variable: $pattern"
              HARDCODED_FOUND=true
            fi
          done
          
          if [ "$HARDCODED_FOUND" = true ]; then
            echo "‚ö†Ô∏è Found hardcoded values (review recommended)"
          else
            echo "‚úÖ No hardcoded values found"
          fi
          
      - name: üìã Upload secrets reports
        uses: actions/upload-artifact@v3
        with:
          name: secrets-scan-reports
          path: |
            gitleaks-report.json

  code-security:
    name: üß™ Code Security Analysis
    runs-on: ubuntu-latest
    if: contains(fromJson('["all", "code_analysis"]'), env.SCAN_TYPE)
    
    steps:
      - name: üìÇ Checkout repository
        uses: actions/checkout@v4
        
      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          
      - name: üì¶ Install security analysis tools
        run: |
          pip install bandit[toml] semgrep
          
      - name: üõ°Ô∏è Bandit security scan
        run: |
          echo "üõ°Ô∏è Running Bandit security scan..."
          
          # Create bandit config if it doesn't exist
          if [ ! -f pyproject.toml ] && [ ! -f .bandit ]; then
            cat > .bandit << EOF
[bandit]
exclude_dirs = ["/tests", "/venv", "/.git"]
skips = ["B101", "B601"]  # Skip assert and shell injection (if needed)
EOF
          fi
          
          if find . -name "*.py" -not -path "./venv/*" | grep -q .; then
            bandit -r . -f json -o bandit-report.json || true
            bandit -r . || true
            
            # Parse results
            if [ -f bandit-report.json ]; then
              HIGH_ISSUES=$(jq '.metrics._totals."SEVERITY.HIGH" // 0' bandit-report.json)
              MEDIUM_ISSUES=$(jq '.metrics._totals."SEVERITY.MEDIUM" // 0' bandit-report.json)
              LOW_ISSUES=$(jq '.metrics._totals."SEVERITY.LOW" // 0' bandit-report.json)
              
              echo "üìä Bandit Results:"
              echo "High: $HIGH_ISSUES, Medium: $MEDIUM_ISSUES, Low: $LOW_ISSUES"
              
              # Fail on high severity issues
              if [ $HIGH_ISSUES -gt 0 ]; then
                echo "‚ùå High severity security issues found"
                jq '.results[] | select(.issue_severity == "HIGH")' bandit-report.json
                exit 1
              fi
            fi
          else
            echo "‚ÑπÔ∏è No Python files found for Bandit scan"
            echo '{"metrics": {"_totals": {"SEVERITY.HIGH": 0}}, "results": []}' > bandit-report.json
          fi
          
      - name: üîç Semgrep security scan
        run: |
          echo "üîç Running Semgrep security scan..."
          
          # Run semgrep with security rules
          semgrep --config=auto --json --output=semgrep-report.json . || true
          semgrep --config=auto . || echo "‚ö†Ô∏è Semgrep found potential issues"
          
          # Parse results
          if [ -f semgrep-report.json ]; then
            CRITICAL_COUNT=$(jq '[.results[] | select(.extra.severity == "ERROR")] | length' semgrep-report.json)
            WARNING_COUNT=$(jq '[.results[] | select(.extra.severity == "WARNING")] | length' semgrep-report.json)
            
            echo "üìä Semgrep Results:"
            echo "Critical: $CRITICAL_COUNT, Warnings: $WARNING_COUNT"
            
            # Fail on critical issues
            if [ $CRITICAL_COUNT -gt 0 ]; then
              echo "‚ùå Critical security issues found"
              jq '.results[] | select(.extra.severity == "ERROR")' semgrep-report.json
              exit 1
            fi
          fi
          
      - name: üîí Shell script security check
        run: |
          echo "üîí Checking shell script security..."
          
          if command -v shellcheck >/dev/null 2>&1; then
            find . -name "*.sh" -not -path "./venv/*" | while read script; do
              echo "Checking $script..."
              shellcheck "$script" || echo "‚ö†Ô∏è ShellCheck found issues in $script"
            done
          else
            echo "‚ö†Ô∏è ShellCheck not available, installing..."
            sudo apt-get update && sudo apt-get install -y shellcheck
            
            find . -name "*.sh" -not -path "./venv/*" | while read script; do
              echo "Checking $script..."
              shellcheck "$script" || echo "‚ö†Ô∏è ShellCheck found issues in $script"
            done
          fi
          
      - name: üìã Upload code security reports
        uses: actions/upload-artifact@v3
        with:
          name: code-security-reports
          path: |
            bandit-report.json
            semgrep-report.json

  container-security:
    name: üê≥ Container Security
    runs-on: ubuntu-latest
    if: contains(fromJson('["all", "container_scan"]'), env.SCAN_TYPE)
    
    steps:
      - name: üìÇ Checkout repository
        uses: actions/checkout@v4
        
      - name: üê≥ Check for Dockerfiles
        id: docker_check
        run: |
          if find . -name "Dockerfile*" -o -name "*.dockerfile" | grep -q .; then
            echo "dockerfiles_found=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Found Dockerfiles to scan"
          else
            echo "dockerfiles_found=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No Dockerfiles found, skipping container scan"
          fi
          
      - name: üõ°Ô∏è Install container security tools
        if: steps.docker_check.outputs.dockerfiles_found == 'true'
        run: |
          # Install trivy
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy
          
      - name: üîç Dockerfile security scan
        if: steps.docker_check.outputs.dockerfiles_found == 'true'
        run: |
          echo "üîç Scanning Dockerfiles for security issues..."
          
          find . -name "Dockerfile*" -o -name "*.dockerfile" | while read dockerfile; do
            echo "Scanning $dockerfile..."
            
            # Trivy filesystem scan for Dockerfile
            trivy fs --security-checks vuln,config "$dockerfile" || true
            
            # Basic Dockerfile best practices check
            echo "Checking best practices for $dockerfile..."
            
            # Check for FROM scratch or FROM alpine (good)
            if grep -q "FROM scratch\|FROM alpine" "$dockerfile"; then
              echo "‚úÖ Using minimal base image"
            elif grep -q "FROM ubuntu\|FROM debian\|FROM centos" "$dockerfile"; then
              echo "‚ö†Ô∏è Using full OS base image (consider alpine or scratch)"
            fi
            
            # Check for USER instruction
            if grep -q "^USER " "$dockerfile"; then
              echo "‚úÖ Non-root user specified"
            else
              echo "‚ö†Ô∏è No USER instruction found (will run as root)"
            fi
            
            # Check for COPY/ADD with specific permissions
            if grep -q "COPY.*--chown\|ADD.*--chown" "$dockerfile"; then
              echo "‚úÖ Using --chown with COPY/ADD"
            else
              echo "‚ÑπÔ∏è Consider using --chown with COPY/ADD instructions"
            fi
            
            echo "---"
          done

  compliance-check:
    name: üìã Compliance & Policy Check
    runs-on: ubuntu-latest
    
    steps:
      - name: üìÇ Checkout repository
        uses: actions/checkout@v4
        
      - name: üìã Check required security files
        run: |
          echo "üìã Checking for required security files..."
          
          REQUIRED_FILES=(
            "SECURITY.md"
            ".github/SECURITY.md"
            "CODE_OF_CONDUCT.md"
            ".github/CODE_OF_CONDUCT.md"
          )
          
          SECURITY_FILE_FOUND=false
          CODE_OF_CONDUCT_FOUND=false
          
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "‚úÖ Found: $file"
              if [[ "$file" == *"SECURITY.md" ]]; then
                SECURITY_FILE_FOUND=true
              fi
              if [[ "$file" == *"CODE_OF_CONDUCT.md" ]]; then
                CODE_OF_CONDUCT_FOUND=true
              fi
            fi
          done
          
          if [ "$SECURITY_FILE_FOUND" = false ]; then
            echo "‚ö†Ô∏è No SECURITY.md file found"
          fi
          
          if [ "$CODE_OF_CONDUCT_FOUND" = false ]; then
            echo "‚ö†Ô∏è No CODE_OF_CONDUCT.md file found"
          fi
          
      - name: üîí Check branch protection compliance
        run: |
          echo "üîí Checking branch protection compliance..."
          
          # This would typically use GitHub API to check branch protection rules
          # For now, we'll just document what should be checked
          
          echo "üìã Branch Protection Checklist:"
          echo "- [ ] Require pull request reviews"
          echo "- [ ] Require status checks to pass"
          echo "- [ ] Require branches to be up to date"
          echo "- [ ] Require conversation resolution"
          echo "- [ ] Restrict pushes to main/master"
          echo "- [ ] Allow force pushes: disabled"
          echo "- [ ] Allow deletions: disabled"